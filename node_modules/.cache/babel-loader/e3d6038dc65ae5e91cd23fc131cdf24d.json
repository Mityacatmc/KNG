{"ast":null,"code":"import { _ as _assert_this_initialized } from \"@swc/helpers/_/_assert_this_initialized\";\nimport { _ as _class_call_check } from \"@swc/helpers/_/_class_call_check\";\nimport { _ as _create_class } from \"@swc/helpers/_/_create_class\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _inherits } from \"@swc/helpers/_/_inherits\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _create_super } from \"@swc/helpers/_/_create_super\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { withContext } from \"../../hoc/withContext\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { canUseDOM, withDOM } from \"../../lib/dom\";\nimport { getNavId } from \"../../lib/getNavId\";\nimport { Platform } from \"../../lib/platform\";\nimport { animationEvent, transitionEvent } from \"../../lib/supportEvents\";\nimport { warnOnce } from \"../../lib/warnOnce\";\nimport { ScrollContext } from \"../AppRoot/ScrollContext\";\nimport { ConfigProviderContext } from \"../ConfigProvider/ConfigProviderContext\";\nimport { NavTransitionProvider } from \"../NavTransitionContext/NavTransitionContext\";\nimport { NavTransitionDirectionProvider } from \"../NavTransitionDirectionContext/NavTransitionDirectionContext\";\nimport { SplitColContext } from \"../SplitCol/SplitColContext\";\nimport { Touch } from \"../Touch/Touch\";\nimport { swipeBackExcluded } from \"./utils\";\nvar warn = warnOnce(\"ViewInfinite\");\nvar SwipeBackResults;\n\n(function (SwipeBackResults) {\n  SwipeBackResults[SwipeBackResults[\"fail\"] = 1] = \"fail\";\n  SwipeBackResults[SwipeBackResults[\"success\"] = 2] = \"success\";\n})(SwipeBackResults || (SwipeBackResults = {}));\n\nexport var scrollsCache = {};\n\nvar _React_Component;\n\nvar ViewInfiniteComponent = /*#__PURE__*/function (_superClass) {\n  \"use strict\";\n\n  _inherits(ViewInfiniteComponent, _superClass);\n\n  var _super = _create_super(ViewInfiniteComponent);\n\n  function ViewInfiniteComponent(props) {\n    _class_call_check(this, ViewInfiniteComponent);\n\n    var _this;\n\n    _this = _super.call(this, props);\n\n    _define_property(_assert_this_initialized(_this), \"scrolls\", scrollsCache[getNavId(_this.props, warn)] || {});\n\n    _define_property(_assert_this_initialized(_this), \"transitionFinishTimeout\", undefined);\n\n    _define_property(_assert_this_initialized(_this), \"animationFinishTimeout\", undefined);\n\n    _define_property(_assert_this_initialized(_this), \"panelNodes\", {});\n\n    _define_property(_assert_this_initialized(_this), \"transitionEndHandler\", function (e) {\n      if ((!e || [\"vkuianimation-ios-next-forward\", \"vkuianimation-ios-prev-back\", \"vkuianimation-view-next-forward\", \"vkuianimation-view-prev-back\"].includes(e.animationName)) && _this.state.prevPanel !== null) {\n        _this.flushTransition(_this.state.prevPanel, Boolean(_this.state.isBack));\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"swipingBackTransitionEndHandler\", function (e) {\n      // indexOf because of vendor prefixes in old browsers\n      if (!e || e.propertyName.includes(\"transform\") && e.target === _this.pickPanel(_this.state.swipeBackNextPanel)) {\n        switch (_this.state.swipeBackResult) {\n          case SwipeBackResults.fail:\n            _this.onSwipeBackCancel();\n\n            break;\n\n          case SwipeBackResults.success:\n            _this.onSwipeBackSuccess();\n\n        }\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"onMoveX\", function (event) {\n      var _this_props_configProvider;\n\n      if (!_this.window || _this.props.platform !== Platform.IOS || _this.state.swipeBackPrevented || swipeBackExcluded(event) || _this.shouldDisableTransitionMotion()) {\n        return;\n      }\n\n      if (!((_this_props_configProvider = _this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.isWebView)) {\n        if ((event.startX <= ViewInfiniteComponent.SWIPE_BACK_AREA || event.startX >= _this.window.innerWidth - ViewInfiniteComponent.SWIPE_BACK_AREA) && !_this.state.browserSwipe) {\n          _this.setState({\n            browserSwipe: true\n          });\n        }\n\n        return;\n      }\n\n      if (!_this.props.onSwipeBack || _this.state.animated && event.startX <= ViewInfiniteComponent.SWIPE_BACK_AREA) {\n        return;\n      }\n\n      if (!_this.state.swipingBack && event.startX <= ViewInfiniteComponent.SWIPE_BACK_AREA && _this.props.history && _this.props.history.length > 1) {\n        if (_this.props.onSwipeBackStart) {\n          var payload = _this.props.onSwipeBackStart(_this.state.activePanel);\n\n          if (payload === \"prevent\") {\n            _this.setState({\n              swipeBackPrevented: true\n            });\n\n            return;\n          }\n        }\n\n        if (_this.state.activePanel !== null) {\n          var _this_props_scroll; // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n\n\n          _this.blurActiveElement();\n\n          var prevScrolls = _this.scrolls[_this.state.activePanel] || [];\n          _this.scrolls = _object_spread_props(_object_spread({}, _this.scrolls), _define_property({}, _this.state.activePanel, _to_consumable_array(prevScrolls).concat([(_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y])));\n        }\n\n        _this.setState({\n          swipingBack: true,\n          swipeBackStartX: event.startX,\n          swipeBackPrevPanel: _this.state.activePanel,\n          swipeBackNextPanel: _this.props.history.slice(-2)[0]\n        });\n      }\n\n      if (_this.state.swipingBack) {\n        var swipeBackShift;\n\n        if (event.shiftX < 0) {\n          swipeBackShift = 0;\n        } else if (event.shiftX > _this.window.innerWidth - _this.state.swipeBackStartX) {\n          swipeBackShift = _this.window.innerWidth;\n        } else {\n          swipeBackShift = event.shiftX;\n        }\n\n        _this.setState({\n          swipeBackShift: swipeBackShift\n        });\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"onEnd\", function (event) {\n      if (_this.state.swipingBack && _this.window) {\n        var speed = _this.state.swipeBackShift / event.duration * 1000;\n\n        if (_this.state.swipeBackShift === 0) {\n          _this.onSwipeBackCancel();\n        } else if (_this.state.swipeBackShift >= _this.window.innerWidth) {\n          _this.onSwipeBackSuccess();\n        } else if (speed > 250 || _this.state.swipeBackStartX + _this.state.swipeBackShift > _this.window.innerWidth / 2) {\n          _this.setState({\n            swipeBackResult: SwipeBackResults.success\n          });\n        } else {\n          _this.setState({\n            swipeBackResult: SwipeBackResults.fail\n          });\n        }\n      }\n\n      if (_this.state.swipeBackPrevented) {\n        _this.setState({\n          swipeBackPrevented: false\n        });\n      }\n    });\n\n    _this.state = {\n      animated: false,\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n      swipingBack: undefined,\n      swipeBackPrevented: false,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n      browserSwipe: false\n    };\n    return _this;\n  }\n\n  _create_class(ViewInfiniteComponent, [{\n    key: \"document\",\n    get: function get() {\n      return this.props.document;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.props.window;\n    }\n  }, {\n    key: \"panels\",\n    get: function get() {\n      return React.Children.toArray(this.props.children);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var id = getNavId(this.props);\n\n      if (id) {\n        scrollsCache[id] = this.scrolls;\n      }\n\n      if (this.animationFinishTimeout) {\n        clearTimeout(this.animationFinishTimeout);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this = this; // Нужен переход\n\n\n      if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {\n        var _this_props_scroll;\n\n        var isBack = false;\n\n        if (this.props.isBackCheck) {\n          isBack = this.props.isBackCheck({\n            from: prevProps.activePanel,\n            to: this.props.activePanel\n          });\n        } else {\n          var firstLayerId = this.panels.map(function (panel) {\n            return getNavId(panel.props, warn);\n          }).find(function (id) {\n            return id === prevProps.activePanel || id === _this.props.activePanel;\n          });\n          isBack = firstLayerId === this.props.activePanel;\n        }\n\n        this.blurActiveElement();\n        var prevScrolls = this.scrolls[prevProps.activePanel] || [];\n\n        var scrolls = _object_spread_props(_object_spread({}, this.scrolls), _define_property({}, prevProps.activePanel, _to_consumable_array(prevScrolls).concat([(_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y])));\n\n        this.scrolls = scrolls;\n\n        if (this.shouldDisableTransitionMotion()) {\n          this.flushTransition(prevProps.activePanel, isBack);\n        } else {\n          this.setState({\n            visiblePanels: [prevProps.activePanel, this.props.activePanel],\n            prevPanel: prevProps.activePanel,\n            nextPanel: this.props.activePanel,\n            activePanel: null,\n            animated: true,\n            isBack: isBack\n          }); // Фолбек анимации перехода\n\n          if (!animationEvent.supported) {\n            if (this.animationFinishTimeout) {\n              clearTimeout(this.animationFinishTimeout);\n            }\n\n            this.animationFinishTimeout = setTimeout(this.transitionEndHandler, this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM ? 300 : 600);\n          }\n        }\n      } // Закончилась анимация свайпа назад\n\n\n      if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n        var nextPanel = this.state.swipeBackNextPanel;\n        var prevPanel = this.state.swipeBackPrevPanel;\n        var scrollPosition = undefined;\n        this.scrolls = _object_spread({}, this.scrolls);\n\n        if (prevPanel !== null) {\n          var prevPanelScrolls = _to_consumable_array(this.scrolls[prevPanel] || []).slice(0, -1);\n\n          this.scrolls[prevPanel] = prevPanelScrolls;\n        }\n\n        if (nextPanel !== null) {\n          var newPanelScrolls = _to_consumable_array(this.scrolls[nextPanel] || []);\n\n          scrollPosition = newPanelScrolls.pop();\n          this.scrolls[nextPanel] = newPanelScrolls;\n        }\n\n        this.setState({\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel]\n        }, function () {\n          var _this_props_scroll;\n\n          (_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, scrollPosition);\n          prevProps.onTransition && prevProps.onTransition({\n            isBack: true,\n            from: prevPanel,\n            to: nextPanel\n          });\n        });\n      } // Началась анимация завершения свайпа назад.\n\n\n      if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n        this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);\n      } // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n\n\n      if (prevState.swipeBackResult === SwipeBackResults.fail && !this.state.swipeBackResult && this.state.activePanel !== null) {\n        var _this_props_scroll1;\n\n        var newPanelScrolls1 = _to_consumable_array(this.scrolls[this.state.activePanel] || []);\n\n        var scrollPosition1 = newPanelScrolls1.pop();\n        this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), _define_property({}, this.state.activePanel, newPanelScrolls1));\n        (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition1);\n      } // Закончился Safari свайп\n\n\n      if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n        this.setState({\n          browserSwipe: false,\n          nextPanel: null,\n          prevPanel: null,\n          animated: false,\n          visiblePanels: [this.props.activePanel],\n          activePanel: this.props.activePanel\n        });\n      }\n    }\n  }, {\n    key: \"shouldDisableTransitionMotion\",\n    value: function shouldDisableTransitionMotion() {\n      var _this_props_configProvider, _this_props_splitCol;\n\n      return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === Platform.VKCOM;\n    }\n  }, {\n    key: \"waitTransitionFinish\",\n    value: function waitTransitionFinish(elem, eventHandler) {\n      if (transitionEvent.supported && transitionEvent.name && elem) {\n        elem.removeEventListener(transitionEvent.name, eventHandler);\n        elem.addEventListener(transitionEvent.name, eventHandler);\n      } else {\n        if (this.transitionFinishTimeout) {\n          clearTimeout(this.transitionFinishTimeout);\n        }\n\n        this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM ? 300 : 600);\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      var _this_document;\n\n      if (typeof this.window !== \"undefined\" && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {\n        this.document.activeElement.blur();\n      }\n    }\n  }, {\n    key: \"pickPanel\",\n    value: function pickPanel(id) {\n      if (id === null) {\n        return undefined;\n      }\n\n      return this.panelNodes[id];\n    }\n  }, {\n    key: \"flushTransition\",\n    value: function flushTransition(prevPanel, isBack) {\n      var _this = this;\n\n      var activePanel = this.props.activePanel;\n\n      var prevPanelScrolls = _to_consumable_array(this.scrolls[prevPanel] || []).slice(0, -1);\n\n      var newPanelScrolls = _to_consumable_array(this.scrolls[activePanel] || []);\n\n      var scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n\n      if (isBack) {\n        var _obj;\n\n        this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), (_obj = {}, _define_property(_obj, prevPanel, prevPanelScrolls), _define_property(_obj, activePanel, newPanelScrolls), _obj));\n      }\n\n      this.setState({\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack: isBack\n      }, function () {\n        var _this_props_scroll;\n\n        (_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);\n        _this.props.onTransition && _this.props.onTransition({\n          isBack: isBack,\n          from: prevPanel,\n          to: activePanel\n        });\n      });\n    }\n  }, {\n    key: \"onSwipeBackSuccess\",\n    value: function onSwipeBackSuccess() {\n      this.props.onSwipeBack && this.props.onSwipeBack();\n    }\n  }, {\n    key: \"onSwipeBackCancel\",\n    value: function onSwipeBackCancel() {\n      this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n      this.setState({\n        swipeBackPrevPanel: null,\n        swipeBackNextPanel: null,\n        swipingBack: false,\n        swipeBackResult: null,\n        swipeBackStartX: 0,\n        swipeBackShift: 0\n      });\n    }\n  }, {\n    key: \"calcPanelSwipeStyles\",\n    value: function calcPanelSwipeStyles(panelId) {\n      if (!canUseDOM || !this.window) {\n        return {};\n      }\n\n      var isPrev = panelId === this.state.swipeBackPrevPanel;\n      var isNext = panelId === this.state.swipeBackNextPanel;\n\n      if (!isPrev && !isNext || this.state.swipeBackResult) {\n        return {};\n      }\n\n      var prevPanelTranslate = \"\".concat(this.state.swipeBackShift, \"px\");\n      var nextPanelTranslate = \"\".concat(-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2, \"%\");\n      var prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;\n\n      if (this.state.swipeBackResult) {\n        return isPrev ? {\n          boxShadow: \"-2px 0 12px rgba(0, 0, 0, \".concat(prevPanelShadow, \")\")\n        } : {};\n      }\n\n      if (isNext) {\n        return {\n          transform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\"),\n          WebkitTransform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\")\n        };\n      }\n\n      if (isPrev) {\n        return {\n          transform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n          WebkitTransform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n          boxShadow: \"-2px 0 12px rgba(0, 0, 0, \".concat(prevPanelShadow, \")\")\n        };\n      }\n\n      return {};\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      var _this_props = this.props,\n          platform = _this_props.platform,\n          _1 = _this_props.activePanel,\n          splitCol = _this_props.splitCol,\n          configProvider = _this_props.configProvider,\n          history = _this_props.history,\n          id = _this_props.id,\n          nav = _this_props.nav,\n          onTransition = _this_props.onTransition,\n          onSwipeBack = _this_props.onSwipeBack,\n          onSwipeBackStart = _this_props.onSwipeBackStart,\n          onSwipeBackCancel = _this_props.onSwipeBackCancel,\n          window = _this_props.window,\n          document = _this_props.document,\n          scroll = _this_props.scroll,\n          isBackCheck = _this_props.isBackCheck,\n          className = _this_props.className,\n          restProps = _object_without_properties(_this_props, [\"platform\", \"activePanel\", \"splitCol\", \"configProvider\", \"history\", \"id\", \"nav\", \"onTransition\", \"onSwipeBack\", \"onSwipeBackStart\", \"onSwipeBackCancel\", \"window\", \"document\", \"scroll\", \"isBackCheck\", \"className\"]);\n\n      var _this_state = this.state,\n          prevPanel = _this_state.prevPanel,\n          nextPanel = _this_state.nextPanel,\n          activePanel = _this_state.activePanel,\n          isBack = _this_state.isBack,\n          animated = _this_state.animated,\n          swipeBackPrevPanel = _this_state.swipeBackPrevPanel,\n          swipeBackNextPanel = _this_state.swipeBackNextPanel,\n          swipeBackResult = _this_state.swipeBackResult,\n          swipingBack = _this_state.swipingBack;\n      var panels = this.panels.filter(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        return panelId !== undefined && _this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;\n      }).sort(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        var isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        var isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n\n        if (isNextPanel) {\n          return swipingBack || _this.state.isBack ? -1 : 1;\n        }\n\n        if (isPrevPanel) {\n          return swipingBack || _this.state.isBack ? 1 : -1;\n        }\n\n        return 0;\n      });\n      var disableAnimation = this.shouldDisableTransitionMotion();\n      return /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({\n        Component: \"section\"\n      }, restProps), {\n        className: classNames(\"vkuiView\", platform === Platform.IOS && classNames(\"vkuiView--ios\", \"vkuiInternalView--ios\"), !disableAnimation && this.state.animated && \"vkuiView--animated\", !disableAnimation && this.state.swipingBack && \"vkuiView--swiping-back\", disableAnimation && \"vkuiView--no-motion\", className),\n        onMoveX: this.onMoveX,\n        onEnd: this.onEnd\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"vkuiView__panels\"\n      }, panels.map(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        var isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        var compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;\n        var isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n        var scrollList = panelId && _this.scrolls[panelId] || [];\n        var scroll = scrollList[scrollList.length - 1] || 0;\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: classNames(\"vkuiView__panel\", panelId === activePanel && \"vkuiView__panel--active\", panelId === prevPanel && \"vkuiView__panel--prev\", panelId === nextPanel && \"vkuiView__panel--next\", panelId === swipeBackPrevPanel && \"vkuiView__panel--swipe-back-prev\", panelId === swipeBackNextPanel && \"vkuiView__panel--swipe-back-next\", swipeBackResult === SwipeBackResults.success && \"vkuiView__panel--swipe-back-success\", swipeBackResult === SwipeBackResults.fail && \"vkuiView__panel--swipe-back-failed\"),\n          onAnimationEnd: isTransitionTarget ? _this.transitionEndHandler : undefined,\n          ref: function ref(el) {\n            return panelId !== undefined && (_this.panelNodes[panelId] = el);\n          },\n          style: _this.calcPanelSwipeStyles(panelId),\n          key: panelId\n        }, /*#__PURE__*/React.createElement(\"div\", {\n          className: \"vkuiView__panel-in\",\n          style: {\n            marginTop: compensateScroll ? -scroll : undefined\n          }\n        }, /*#__PURE__*/React.createElement(NavTransitionDirectionProvider, {\n          isBack: swipingBack || isBack\n        }, /*#__PURE__*/React.createElement(NavTransitionProvider, {\n          entering: panelId === nextPanel || panelId === swipeBackNextPanel\n        }, panel))));\n      })));\n    }\n  }]);\n\n  return ViewInfiniteComponent;\n}(_React_Component = React.Component);\n\n_define_property(ViewInfiniteComponent, \"SWIPE_BACK_AREA\", 70);\n\n_define_property(ViewInfiniteComponent, \"defaultProps\", {\n  history: []\n});\n\nexport var ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, \"splitCol\"), ConfigProviderContext, \"configProvider\"), ScrollContext, \"scroll\");","map":{"version":3,"mappings":"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","names":["React","classNames","withContext","withPlatform","canUseDOM","withDOM","getNavId","Platform","animationEvent","transitionEvent","warnOnce","ScrollContext","ConfigProviderContext","NavTransitionProvider","NavTransitionDirectionProvider","SplitColContext","Touch","swipeBackExcluded","warn","SwipeBackResults","fail","success","scrollsCache","ViewInfiniteComponent","_superClass","props","_define_property","scrolls","_this","transitionFinishTimeout","undefined","animationFinishTimeout","panelNodes","transitionEndHandler","e","includes","animationName","state","prevPanel","flushTransition","Boolean","isBack","swipingBackTransitionEndHandler","propertyName","target","pickPanel","swipeBackNextPanel","swipeBackResult","onSwipeBackCancel","onSwipeBackSuccess","onMoveX","event","_this_props_configProvider","window","platform","IOS","swipeBackPrevented","shouldDisableTransitionMotion","configProvider","isWebView","startX","SWIPE_BACK_AREA","innerWidth","browserSwipe","setState","onSwipeBack","animated","swipingBack","history","length","onSwipeBackStart","payload","activePanel","_this_props_scroll","blurActiveElement","prevScrolls","_object_spread_props","_to_consumable_array","scroll","getScroll","y","swipeBackStartX","swipeBackPrevPanel","slice","swipeBackShift","shiftX","onEnd","speed","duration","visiblePanels","nextPanel","document","panels","Children","toArray","children","componentWillUnmount","id","clearTimeout","componentDidUpdate","prevProps","prevState","isBackCheck","from","to","firstLayerId","map","panel","find","supported","setTimeout","ANDROID","VKCOM","scrollPosition","_object_spread","prevPanelScrolls","newPanelScrolls","pop","scrollTo","onTransition","waitTransitionFinish","_this_props_scroll1","_this_props_splitCol","transitionMotionEnabled","splitCol","animate","elem","eventHandler","name","removeEventListener","addEventListener","_this_document","activeElement","blur","_obj","calcPanelSwipeStyles","panelId","isPrev","isNext","prevPanelTranslate","concat","nextPanelTranslate","prevPanelShadow","boxShadow","transform","WebkitTransform","render","_this_props","_1","nav","className","restProps","_this_state","filter","sort","isPrevPanel","isNextPanel","disableAnimation","Component","div","compensateScroll","isTransitionTarget","scrollList","onAnimationEnd","ref","el","style","key","marginTop","entering","defaultProps","ViewInfinite"],"sources":["C:\\Users\\Я\\Desktop\\myproject\\vk-miniapps\\Koto-app\\node_modules\\@vkontakte\\vkui\\src\\components\\View\\ViewInfinite.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { withContext } from '../../hoc/withContext';\nimport { withPlatform } from '../../hoc/withPlatform';\nimport { canUseDOM, DOMProps, withDOM } from '../../lib/dom';\nimport { getNavId, NavIdProps } from '../../lib/getNavId';\nimport { Platform } from '../../lib/platform';\nimport { animationEvent, transitionEvent } from '../../lib/supportEvents';\nimport { warnOnce } from '../../lib/warnOnce';\nimport { HasPlatform, HTMLAttributesWithRootRef } from '../../types';\nimport { ScrollContext, ScrollContextInterface } from '../AppRoot/ScrollContext';\nimport {\n  ConfigProviderContext,\n  ConfigProviderContextInterface,\n} from '../ConfigProvider/ConfigProviderContext';\nimport { NavTransitionProvider } from '../NavTransitionContext/NavTransitionContext';\nimport { NavTransitionDirectionProvider } from '../NavTransitionDirectionContext/NavTransitionDirectionContext';\nimport { SplitColContext, SplitColContextProps } from '../SplitCol/SplitColContext';\nimport { Touch, TouchEvent } from '../Touch/Touch';\nimport { swipeBackExcluded } from './utils';\nimport styles from './View.module.css';\n\nconst warn = warnOnce('ViewInfinite');\n\nenum SwipeBackResults {\n  fail = 1,\n  success,\n}\n\ninterface Scrolls {\n  [index: string]: Array<number | undefined>;\n}\n\ninterface ViewsScrolls {\n  [index: string]: Scrolls;\n}\n\ntype TransitionEventHandler = (e?: TransitionEvent) => void;\n\nexport let scrollsCache: ViewsScrolls = {};\n\nexport type TransitionParams = { from: string | null; to: string | null };\n\nexport interface ViewInfiniteProps\n  extends HTMLAttributesWithRootRef<HTMLElement>,\n    HasPlatform,\n    NavIdProps {\n  activePanel: string;\n  onTransition?(params: TransitionParams & { isBack: boolean }): void;\n  /**\n   * callback свайпа назад\n   */\n  onSwipeBack?(): void;\n  /**\n   * callback начала анимации свайпа назад.\n   */\n  onSwipeBackStart?(activePanel: string | null): void | 'prevent';\n  /**\n   * callback завершения анимации отмененного пользователем свайпа\n   */\n  onSwipeBackCancel?(): void;\n  history?: string[];\n  isBackCheck?(params: TransitionParams): boolean;\n  /**\n   * @ignore\n   */\n  splitCol?: SplitColContextProps;\n  /**\n   * @ignore\n   */\n  configProvider?: ConfigProviderContextInterface;\n  /**\n   * @ignore\n   */\n  scroll?: ScrollContextInterface;\n}\n\nexport interface ViewInfiniteState {\n  animated: boolean;\n\n  visiblePanels: Array<string | null>;\n  activePanel: string | null;\n  isBack?: boolean;\n  prevPanel: string | null;\n  nextPanel: string | null;\n\n  swipingBack?: boolean;\n  swipeBackPrevented: boolean;\n  swipeBackStartX: number;\n  swipeBackShift: number;\n  swipeBackNextPanel: string | null;\n  swipeBackPrevPanel: string | null;\n  swipeBackResult: SwipeBackResults | null;\n\n  browserSwipe: boolean;\n}\n\nclass ViewInfiniteComponent extends React.Component<\n  ViewInfiniteProps & DOMProps,\n  ViewInfiniteState\n> {\n  private static readonly SWIPE_BACK_AREA = 70;\n\n  constructor(props: ViewInfiniteProps) {\n    super(props);\n\n    this.state = {\n      animated: false,\n\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n\n      swipingBack: undefined,\n      swipeBackPrevented: false,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n\n      browserSwipe: false,\n    };\n  }\n\n  static defaultProps: Partial<ViewInfiniteProps> = {\n    history: [],\n  };\n\n  private scrolls = scrollsCache[getNavId(this.props, warn) as string] || {};\n  private transitionFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n  private animationFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n\n  get document() {\n    return this.props.document;\n  }\n\n  get window() {\n    return this.props.window;\n  }\n\n  get panels() {\n    return React.Children.toArray(this.props.children) as React.ReactElement[];\n  }\n\n  panelNodes: { [id: string]: HTMLDivElement | null } = {};\n\n  componentWillUnmount() {\n    const id = getNavId(this.props);\n    if (id) {\n      scrollsCache[id] = this.scrolls;\n    }\n    if (this.animationFinishTimeout) {\n      clearTimeout(this.animationFinishTimeout);\n    }\n  }\n\n  componentDidUpdate(prevProps: ViewInfiniteProps, prevState: ViewInfiniteState) {\n    // Нужен переход\n    if (\n      prevProps.activePanel !== this.props.activePanel &&\n      !prevState.swipingBack &&\n      !prevState.browserSwipe\n    ) {\n      let isBack = false;\n\n      if (this.props.isBackCheck) {\n        isBack = this.props.isBackCheck({\n          from: prevProps.activePanel,\n          to: this.props.activePanel,\n        });\n      } else {\n        const firstLayerId = this.panels\n          .map((panel) => getNavId(panel.props, warn))\n          .find((id) => id === prevProps.activePanel || id === this.props.activePanel);\n        isBack = firstLayerId === this.props.activePanel;\n      }\n\n      this.blurActiveElement();\n\n      const prevScrolls = this.scrolls[prevProps.activePanel] || [];\n      const scrolls = {\n        ...this.scrolls,\n        [prevProps.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n      };\n      this.scrolls = scrolls;\n\n      if (this.shouldDisableTransitionMotion()) {\n        this.flushTransition(prevProps.activePanel, isBack);\n      } else {\n        this.setState({\n          visiblePanels: [prevProps.activePanel, this.props.activePanel],\n          prevPanel: prevProps.activePanel,\n          nextPanel: this.props.activePanel,\n          activePanel: null,\n          animated: true,\n          isBack,\n        });\n\n        // Фолбек анимации перехода\n        if (!animationEvent.supported) {\n          if (this.animationFinishTimeout) {\n            clearTimeout(this.animationFinishTimeout);\n          }\n          this.animationFinishTimeout = setTimeout(\n            this.transitionEndHandler,\n            this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM\n              ? 300\n              : 600,\n          );\n        }\n      }\n    }\n\n    // Закончилась анимация свайпа назад\n    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n      const nextPanel = this.state.swipeBackNextPanel;\n      const prevPanel = this.state.swipeBackPrevPanel;\n      let scrollPosition: undefined | number = undefined;\n\n      this.scrolls = {\n        ...this.scrolls,\n      };\n\n      if (prevPanel !== null) {\n        const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n        this.scrolls[prevPanel] = prevPanelScrolls;\n      }\n      if (nextPanel !== null) {\n        const newPanelScrolls = [...(this.scrolls[nextPanel] || [])];\n        scrollPosition = newPanelScrolls.pop();\n        this.scrolls[nextPanel] = newPanelScrolls;\n      }\n\n      this.setState(\n        {\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel],\n        },\n        () => {\n          this.props.scroll?.scrollTo(0, scrollPosition);\n          prevProps.onTransition &&\n            prevProps.onTransition({\n              isBack: true,\n              from: prevPanel,\n              to: nextPanel,\n            });\n        },\n      );\n    }\n\n    // Началась анимация завершения свайпа назад.\n    if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n      this.waitTransitionFinish(\n        this.pickPanel(this.state.swipeBackNextPanel),\n        this.swipingBackTransitionEndHandler,\n      );\n    }\n\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (\n      prevState.swipeBackResult === SwipeBackResults.fail &&\n      !this.state.swipeBackResult &&\n      this.state.activePanel !== null\n    ) {\n      const newPanelScrolls = [...(this.scrolls[this.state.activePanel] || [])];\n      const scrollPosition = newPanelScrolls.pop();\n      this.scrolls = {\n        ...this.scrolls,\n        [this.state.activePanel]: newPanelScrolls,\n      };\n\n      this.props.scroll?.scrollTo(0, scrollPosition);\n    }\n\n    // Закончился Safari свайп\n    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n      this.setState({\n        browserSwipe: false,\n        nextPanel: null,\n        prevPanel: null,\n        animated: false,\n        visiblePanels: [this.props.activePanel],\n        activePanel: this.props.activePanel,\n      });\n    }\n  }\n\n  shouldDisableTransitionMotion(): boolean {\n    return (\n      this.props.configProvider?.transitionMotionEnabled === false ||\n      !this.props.splitCol?.animate ||\n      this.props.platform === Platform.VKCOM\n    );\n  }\n\n  waitTransitionFinish(\n    elem: HTMLElement | null | undefined,\n    eventHandler: TransitionEventHandler,\n  ): void {\n    if (transitionEvent.supported && transitionEvent.name && elem) {\n      elem.removeEventListener(\n        transitionEvent.name as keyof HTMLElementEventMap,\n        eventHandler as EventListener,\n      );\n      elem.addEventListener(\n        transitionEvent.name as keyof HTMLElementEventMap,\n        eventHandler as EventListener,\n      );\n    } else {\n      if (this.transitionFinishTimeout) {\n        clearTimeout(this.transitionFinishTimeout);\n      }\n\n      this.transitionFinishTimeout = setTimeout(\n        eventHandler,\n        this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM\n          ? 300\n          : 600,\n      );\n    }\n  }\n\n  blurActiveElement(): void {\n    if (typeof this.window !== 'undefined' && this.document?.activeElement) {\n      (this.document.activeElement as HTMLElement).blur();\n    }\n  }\n\n  pickPanel(id: string | null) {\n    if (id === null) {\n      return undefined;\n    }\n    return this.panelNodes[id];\n  }\n\n  flushTransition(prevPanel: string, isBack: boolean) {\n    const activePanel = this.props.activePanel;\n\n    const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n    const newPanelScrolls = [...(this.scrolls[activePanel] || [])];\n    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n    if (isBack) {\n      this.scrolls = {\n        ...this.scrolls,\n        [prevPanel]: prevPanelScrolls,\n        [activePanel]: newPanelScrolls,\n      };\n    }\n\n    this.setState(\n      {\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack,\n      },\n      () => {\n        this.props.scroll?.scrollTo(0, isBack ? scrollPosition : 0);\n        this.props.onTransition &&\n          this.props.onTransition({ isBack, from: prevPanel, to: activePanel });\n      },\n    );\n  }\n\n  transitionEndHandler = (e?: React.AnimationEvent): void => {\n    if (\n      (!e ||\n        [\n          styles['animation-ios-next-forward'],\n          styles['animation-ios-prev-back'],\n          styles['animation-view-next-forward'],\n          styles['animation-view-prev-back'],\n        ].includes(e.animationName)) &&\n      this.state.prevPanel !== null\n    ) {\n      this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));\n    }\n  };\n\n  swipingBackTransitionEndHandler = (e?: TransitionEvent): void => {\n    // indexOf because of vendor prefixes in old browsers\n    if (\n      !e ||\n      (e.propertyName.includes('transform') &&\n        e.target === this.pickPanel(this.state.swipeBackNextPanel))\n    ) {\n      switch (this.state.swipeBackResult) {\n        case SwipeBackResults.fail:\n          this.onSwipeBackCancel();\n          break;\n        case SwipeBackResults.success:\n          this.onSwipeBackSuccess();\n      }\n    }\n  };\n\n  onSwipeBackSuccess(): void {\n    this.props.onSwipeBack && this.props.onSwipeBack();\n  }\n\n  onSwipeBackCancel(): void {\n    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n    this.setState({\n      swipeBackPrevPanel: null,\n      swipeBackNextPanel: null,\n      swipingBack: false,\n      swipeBackResult: null,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n    });\n  }\n\n  onMoveX = (event: TouchEvent): void => {\n    if (\n      !this.window ||\n      this.props.platform !== Platform.IOS ||\n      this.state.swipeBackPrevented ||\n      swipeBackExcluded(event) ||\n      this.shouldDisableTransitionMotion()\n    ) {\n      return;\n    }\n\n    if (!this.props.configProvider?.isWebView) {\n      if (\n        (event.startX <= ViewInfiniteComponent.SWIPE_BACK_AREA ||\n          event.startX >= this.window.innerWidth - ViewInfiniteComponent.SWIPE_BACK_AREA) &&\n        !this.state.browserSwipe\n      ) {\n        this.setState({ browserSwipe: true });\n      }\n\n      return;\n    }\n\n    if (\n      !this.props.onSwipeBack ||\n      (this.state.animated && event.startX <= ViewInfiniteComponent.SWIPE_BACK_AREA)\n    ) {\n      return;\n    }\n\n    if (\n      !this.state.swipingBack &&\n      event.startX <= ViewInfiniteComponent.SWIPE_BACK_AREA &&\n      this.props.history &&\n      this.props.history.length > 1\n    ) {\n      if (this.props.onSwipeBackStart) {\n        const payload = this.props.onSwipeBackStart(this.state.activePanel);\n        if (payload === 'prevent') {\n          this.setState({ swipeBackPrevented: true });\n          return;\n        }\n      }\n\n      if (this.state.activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        this.blurActiveElement();\n        const prevScrolls = this.scrolls[this.state.activePanel] || [];\n        this.scrolls = {\n          ...this.scrolls,\n          [this.state.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n        };\n      }\n\n      this.setState({\n        swipingBack: true,\n        swipeBackStartX: event.startX,\n        swipeBackPrevPanel: this.state.activePanel,\n        swipeBackNextPanel: this.props.history.slice(-2)[0],\n      });\n    }\n\n    if (this.state.swipingBack) {\n      let swipeBackShift;\n      if (event.shiftX < 0) {\n        swipeBackShift = 0;\n      } else if (event.shiftX > this.window.innerWidth - this.state.swipeBackStartX) {\n        swipeBackShift = this.window.innerWidth;\n      } else {\n        swipeBackShift = event.shiftX;\n      }\n      this.setState({ swipeBackShift });\n    }\n  };\n\n  onEnd = (event: TouchEvent): void => {\n    if (this.state.swipingBack && this.window) {\n      const speed = (this.state.swipeBackShift / event.duration) * 1000;\n      if (this.state.swipeBackShift === 0) {\n        this.onSwipeBackCancel();\n      } else if (this.state.swipeBackShift >= this.window.innerWidth) {\n        this.onSwipeBackSuccess();\n      } else if (\n        speed > 250 ||\n        this.state.swipeBackStartX + this.state.swipeBackShift > this.window.innerWidth / 2\n      ) {\n        this.setState({ swipeBackResult: SwipeBackResults.success });\n      } else {\n        this.setState({ swipeBackResult: SwipeBackResults.fail });\n      }\n    }\n    if (this.state.swipeBackPrevented) {\n      this.setState({ swipeBackPrevented: false });\n    }\n  };\n\n  calcPanelSwipeStyles(panelId: string | undefined): React.CSSProperties {\n    if (!canUseDOM || !this.window) {\n      return {};\n    }\n\n    const isPrev = panelId === this.state.swipeBackPrevPanel;\n    const isNext = panelId === this.state.swipeBackNextPanel;\n\n    if ((!isPrev && !isNext) || this.state.swipeBackResult) {\n      return {};\n    }\n\n    let prevPanelTranslate = `${this.state.swipeBackShift}px`;\n    let nextPanelTranslate = `${\n      -50 + (this.state.swipeBackShift * 100) / this.window.innerWidth / 2\n    }%`;\n    let prevPanelShadow =\n      (0.3 * (this.window.innerWidth - this.state.swipeBackShift)) / this.window.innerWidth;\n\n    if (this.state.swipeBackResult) {\n      return isPrev ? { boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})` } : {};\n    }\n\n    if (isNext) {\n      return {\n        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`,\n      };\n    }\n\n    return {};\n  }\n\n  render() {\n    const {\n      platform,\n      activePanel: _1,\n      splitCol,\n      configProvider,\n      history,\n      id,\n      nav,\n      onTransition,\n      onSwipeBack,\n      onSwipeBackStart,\n      onSwipeBackCancel,\n      window,\n      document,\n      scroll,\n      isBackCheck,\n      className,\n      ...restProps\n    } = this.props;\n    const {\n      prevPanel,\n      nextPanel,\n      activePanel,\n      isBack,\n      animated,\n      swipeBackPrevPanel,\n      swipeBackNextPanel,\n      swipeBackResult,\n      swipingBack,\n    } = this.state;\n\n    const panels = this.panels\n      .filter((panel) => {\n        const panelId = getNavId(panel.props, warn);\n\n        return (\n          (panelId !== undefined && this.state.visiblePanels.includes(panelId)) ||\n          panelId === swipeBackPrevPanel ||\n          panelId === swipeBackNextPanel\n        );\n      })\n      .sort((panel) => {\n        const panelId = getNavId(panel.props, warn);\n        const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n\n        if (isNextPanel) {\n          return swipingBack || this.state.isBack ? -1 : 1;\n        }\n\n        if (isPrevPanel) {\n          return swipingBack || this.state.isBack ? 1 : -1;\n        }\n\n        return 0;\n      });\n\n    const disableAnimation = this.shouldDisableTransitionMotion();\n\n    return (\n      <Touch\n        Component=\"section\"\n        {...restProps}\n        className={classNames(\n          styles['View'],\n          platform === Platform.IOS && classNames(styles['View--ios'], 'vkuiInternalView--ios'),\n          !disableAnimation && this.state.animated && styles['View--animated'],\n          !disableAnimation && this.state.swipingBack && styles['View--swiping-back'],\n          disableAnimation && styles['View--no-motion'],\n          className,\n        )}\n        onMoveX={this.onMoveX}\n        onEnd={this.onEnd}\n      >\n        <div className={styles['View__panels']}>\n          {panels.map((panel: React.ReactElement) => {\n            const panelId = getNavId(panel.props, warn);\n            const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n            const compensateScroll =\n              isPrev || panelId === swipeBackNextPanel || (panelId === nextPanel && isBack);\n            const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n            const scrollList = (panelId && this.scrolls[panelId]) || [];\n            const scroll = scrollList[scrollList.length - 1] || 0;\n\n            return (\n              <div\n                className={classNames(\n                  styles['View__panel'],\n                  panelId === activePanel && styles['View__panel--active'],\n                  panelId === prevPanel && styles['View__panel--prev'],\n                  panelId === nextPanel && styles['View__panel--next'],\n                  panelId === swipeBackPrevPanel && styles['View__panel--swipe-back-prev'],\n                  panelId === swipeBackNextPanel && styles['View__panel--swipe-back-next'],\n                  swipeBackResult === SwipeBackResults.success &&\n                    styles['View__panel--swipe-back-success'],\n                  swipeBackResult === SwipeBackResults.fail &&\n                    styles['View__panel--swipe-back-failed'],\n                )}\n                onAnimationEnd={isTransitionTarget ? this.transitionEndHandler : undefined}\n                ref={(el) => panelId !== undefined && (this.panelNodes[panelId] = el)}\n                style={this.calcPanelSwipeStyles(panelId)}\n                key={panelId}\n              >\n                <div\n                  className={styles['View__panel-in']}\n                  style={{ marginTop: compensateScroll ? -scroll : undefined }}\n                >\n                  <NavTransitionDirectionProvider isBack={swipingBack || isBack}>\n                    <NavTransitionProvider\n                      entering={panelId === nextPanel || panelId === swipeBackNextPanel}\n                    >\n                      {panel}\n                    </NavTransitionProvider>\n                  </NavTransitionDirectionProvider>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </Touch>\n    );\n  }\n}\n\nexport const ViewInfinite = withContext(\n  withContext(\n    withContext(\n      withPlatform(withDOM<ViewInfiniteProps>(ViewInfiniteComponent)),\n      SplitColContext,\n      'splitCol',\n    ),\n    ConfigProviderContext,\n    'configProvider',\n  ),\n  ScrollContext,\n  'scroll',\n);\n"]},"metadata":{},"sourceType":"module"}