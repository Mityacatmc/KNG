{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { classNames, noop } from \"@vkontakte/vkjs\";\nimport { useAdaptivityHasPointer } from \"../../hooks/useAdaptivityHasPointer\";\nimport { useEventListener } from \"../../hooks/useEventListener\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { easeInOutSine } from \"../../lib/fx\";\nimport { RootComponent } from \"../RootComponent/RootComponent\";\nimport { ScrollArrow } from \"../ScrollArrow/ScrollArrow\";\n/**\n * timing method\n */\n\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\n\n\nvar roundUpElementScrollLeft = function roundUpElementScrollLeft(el) {\n  return Math.ceil(el.scrollLeft);\n};\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\n\n\nvar SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll(param) {\n  var scrollElement = param.scrollElement,\n      getScrollPosition = param.getScrollPosition,\n      animationQueue = param.animationQueue,\n      onScrollToRightBorder = param.onScrollToRightBorder,\n      onScrollEnd = param.onScrollEnd,\n      onScrollStart = param.onScrollStart,\n      initialScrollWidth = param.initialScrollWidth,\n      _param_scrollAnimationDuration = param.scrollAnimationDuration,\n      scrollAnimationDuration = _param_scrollAnimationDuration === void 0 ? SCROLL_ONE_FRAME_TIME : _param_scrollAnimationDuration;\n\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n  /**\n  * максимальное значение сдвига влево\n  */\n\n\n  var maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n  var startLeft = roundUpElementScrollLeft(scrollElement);\n  var endLeft = getScrollPosition(startLeft);\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  var startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    var time = now();\n    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    var value = easeInOutSine(elapsed);\n    var currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (roundUpElementScrollLeft(scrollElement) !== Math.max(0, endLeft) && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\n\n\nexport var HorizontalScroll = function HorizontalScroll(_param) {\n  var children = _param.children,\n      getScrollToLeft = _param.getScrollToLeft,\n      getScrollToRight = _param.getScrollToRight,\n      _param_showArrows = _param.showArrows,\n      showArrows = _param_showArrows === void 0 ? true : _param_showArrows,\n      _param_arrowSize = _param.arrowSize,\n      arrowSize = _param_arrowSize === void 0 ? \"l\" : _param_arrowSize,\n      arrowOffsetY = _param.arrowOffsetY,\n      _param_scrollAnimationDuration = _param.scrollAnimationDuration,\n      scrollAnimationDuration = _param_scrollAnimationDuration === void 0 ? SCROLL_ONE_FRAME_TIME : _param_scrollAnimationDuration,\n      getRef = _param.getRef,\n      _param_scrollOnAnyWheel = _param.scrollOnAnyWheel,\n      scrollOnAnyWheel = _param_scrollOnAnyWheel === void 0 ? false : _param_scrollOnAnyWheel,\n      restProps = _object_without_properties(_param, [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"arrowSize\", \"arrowOffsetY\", \"scrollAnimationDuration\", \"getRef\", \"scrollOnAnyWheel\"]);\n\n  var _React_useState = _sliced_to_array(React.useState(false), 2),\n      canScrollLeft = _React_useState[0],\n      setCanScrollLeft = _React_useState[1];\n\n  var _React_useState1 = _sliced_to_array(React.useState(false), 2),\n      canScrollRight = _React_useState1[0],\n      setCanScrollRight = _React_useState1[1];\n\n  var isCustomScrollingRef = React.useRef(false);\n  var scrollerRef = useExternRef(getRef);\n  var animationQueue = React.useRef([]);\n  var hasPointer = useAdaptivityHasPointer();\n  var scrollTo = React.useCallback(function (getScrollPosition) {\n    var scrollElement = scrollerRef.current;\n    animationQueue.current.push(function () {\n      var _scrollElement_firstElementChild, _scrollElement;\n\n      return doScroll({\n        scrollElement: scrollElement,\n        getScrollPosition: getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToRightBorder: function onScrollToRightBorder() {\n          return setCanScrollRight(false);\n        },\n        onScrollEnd: function onScrollEnd() {\n          return isCustomScrollingRef.current = false;\n        },\n        onScrollStart: function onScrollStart() {\n          return isCustomScrollingRef.current = true;\n        },\n        initialScrollWidth: ((_scrollElement = scrollElement) === null || _scrollElement === void 0 ? void 0 : (_scrollElement_firstElementChild = _scrollElement.firstElementChild) === null || _scrollElement_firstElementChild === void 0 ? void 0 : _scrollElement_firstElementChild.scrollWidth) || 0,\n        scrollAnimationDuration: scrollAnimationDuration\n      });\n    });\n\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }, [scrollAnimationDuration, scrollerRef]);\n  var scrollToLeft = React.useCallback(function () {\n    var getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : function (i) {\n      return i - scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n  var scrollToRight = React.useCallback(function () {\n    var getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : function (i) {\n      return i + scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n  var calculateArrowsVisibility = React.useCallback(function () {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      var scrollElement = scrollerRef.current;\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(roundUpElementScrollLeft(scrollElement) + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [hasPointer, scrollerRef, showArrows]);\n  var scrollEvent = useEventListener(\"scroll\", calculateArrowsVisibility);\n  React.useEffect(function addScrollerRefToScrollEvent() {\n    if (!scrollerRef.current) {\n      return noop;\n    }\n\n    scrollEvent.add(scrollerRef.current);\n    return scrollEvent.remove;\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(calculateArrowsVisibility, [calculateArrowsVisibility, children]);\n  /**\n  * Прокрутка с помощью любого колеса мыши\n  */\n\n  var onwheel = React.useCallback(function (e) {\n    scrollerRef.current.scrollBy({\n      left: e.deltaX + e.deltaY,\n      behavior: \"auto\"\n    });\n    e.preventDefault();\n  }, [scrollerRef]);\n  var wheelEvent = useEventListener(\"wheel\", onwheel);\n  React.useEffect(function addScrollerRefToWheelEvent() {\n    if (!scrollerRef.current || !scrollOnAnyWheel) {\n      return noop;\n    }\n\n    wheelEvent.add(scrollerRef.current);\n    return wheelEvent.remove;\n  }, [wheelEvent, scrollerRef, scrollOnAnyWheel]);\n  return /*#__PURE__*/React.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {\n    baseClassName: classNames(\"vkuiHorizontalScroll\", \"vkuiInternalHorizontalScroll\", showArrows === \"always\" && \"vkuiHorizontalScroll--withConstArrows\"),\n    onMouseEnter: calculateArrowsVisibility\n  }), showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && /*#__PURE__*/React.createElement(ScrollArrow, {\n    size: arrowSize,\n    offsetY: arrowOffsetY,\n    direction: \"left\",\n    className: classNames(\"vkuiHorizontalScroll__arrow\", \"vkuiHorizontalScroll__arrowLeft\"),\n    onClick: scrollToLeft\n  }), showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && /*#__PURE__*/React.createElement(ScrollArrow, {\n    size: arrowSize,\n    offsetY: arrowOffsetY,\n    direction: \"right\",\n    className: classNames(\"vkuiHorizontalScroll__arrow\", \"vkuiHorizontalScroll__arrowRight\"),\n    onClick: scrollToRight\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in\",\n    ref: scrollerRef\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in-wrapper\"\n  }, children)));\n};","map":{"version":3,"mappings":";;;;AAAA,YAAYA,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,EAAqBC,IAArB,QAAiC,iBAAjC;AACA,SAASC,uBAAT,QAAwC,qCAAxC;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,YAAT,QAA6B,0BAA7B;AACA,SAASC,aAAT,QAA8B,cAA9B;AAEA,SAASC,aAAT,QAA8B,gCAA9B;AACA,SAASC,WAAT,QAA4B,4BAA5B;AA6CA;;;;AAGA,SAASC,GAAT,GAASA;EACP,OAAOC,eAAeA,YAAYD,GAA3BC,GAAiCA,YAAYD,GAAZC,EAAjCA,GAAqDC,KAAKF,GAALE,EAA5D;AACF;AAEA;;;;;;AAIA,IAAMC,2BAA2B,SAA3BA,wBAA2B,CAACC,EAAD,EAACA;SAAoBC,KAAKC,IAALD,CAAUD,GAAGG,UAAbF;CAAtD;AAEA;;;;;;;AAKA,IAAMG,wBAAwB,GAA9B;;AAEA,SAASC,QAAT,CAAkBC,KAAlB,EASgB;MARdC,gBADgBD,MAChBC;MACAC,oBAFgBF,MAEhBE;MACAC,iBAHgBH,MAGhBG;MACAC,wBAJgBJ,MAIhBI;MACAC,cALgBL,MAKhBK;MACAC,gBANgBN,MAMhBM;MACAC,qBAPgBP,MAOhBO;MAAAA,iCAPgBP,MAQhBQ;MAAAA,sEAA0BV,qBAA1BU,GAA0BV;;EAE1B,IAAI,CAACG,aAAD,IAAkB,CAACC,iBAAvB,EAA0C;IACxC;EACF;EAEA;;;;;EAGA,IAAMO,UAAUF,qBAAqBN,cAAcS,WAAnD;EAEA,IAAIC,YAAYlB,yBAAyBQ,aAAzBR,CAAhB;EACA,IAAImB,UAAUV,kBAAkBS,SAAlBT,CAAd;EAEAI;;EAEA,IAAIM,WAAWH,OAAf,EAAwB;IACtBL;IACAQ,UAAUH,OAAVG;EACF;;EAEA,IAAMC,YAAYvB,KAAlB;;EAEC,UAASwB,MAAT,GAASA;IACR,IAAI,CAACb,aAAL,EAAoB;MAClBI;MACA;IACF;;IAEA,IAAMU,OAAOzB,KAAb;IACA,IAAM0B,UAAUrB,KAAKsB,GAALtB,CAAS,CAACoB,OAAOF,SAAR,IAAqBL,uBAA9Bb,EAAuD,CAAvDA,CAAhB;IAEA,IAAMuB,QAAQ/B,cAAc6B,OAAd7B,CAAd;IAEA,IAAMgC,cAAcR,YAAY,CAACC,UAAUD,SAAX,IAAwBO,KAAxD;IACAjB,cAAcJ,UAAdI,GAA2BN,KAAKC,IAALD,CAAUwB,WAAVxB,CAA3BM;;IAEA,IAAIR,yBAAyBQ,aAAzBR,MAA4CE,KAAKyB,GAALzB,CAAS,CAATA,EAAYiB,OAAZjB,CAA5CF,IAAoEuB,YAAY,CAApF,EAAuF;MACrFK,sBAAsBP,MAAtBO;MACA;IACF;;IAEAhB;IACAF,eAAemB,KAAfnB;;IACA,IAAIA,eAAeoB,MAAfpB,GAAwB,CAA5B,EAA+B;MAC7BA,cAAc,CAAC,CAAD,CAAdA;IACF;EACF,CAxBC;AAyBH;AAEA;;;;;AAGA,OAAO,IAAMqB,mBAAmB,SAAnBA,gBAAmB;MAC9BC;MACAC;MACAC;MAAAA,2BACAC;MAAAA,4CAAa,IAAbA,GAAaC;MAAAC,0BACbC;MAAAA,0CAAY,GAAZA,GAAYD;MACZE;MAAAA,wCACAxB;MAAAA,sEAA0BV,qBAA1BU,GAA0BV;MAC1BmC;MAAAA,iCACAC;MAAAA,wDAAmB,KAAnBA,GAAmBC;MAChBC,gDATHX,UASGW,EARHV,iBAQGU,EAPHT,kBAOGS,EANHR,YAMGQ,EALHL,WAKGK,EAJHJ,cAIGI,EAHH5B,yBAGG4B,EAFHH,QAEGG,EADHF,kBACGE;;EAEH,IAA0CvD,yCAAMwD,QAANxD,CAAe,KAAfA,GAAe,CAAfA,CAA1C;EAAA,IAAOyD,gBAAmCzD,kBAA1C;EAAA,IAAsB0D,mBAAoB1D,kBAA1C;;EACA,IAA4CA,0CAAMwD,QAANxD,CAAe,KAAfA,GAAe,CAAfA,CAA5C;EAAA,IAAO2D,iBAAqC3D,mBAA5C;EAAA,IAAuB4D,oBAAqB5D,mBAA5C;;EAEA,IAAM6D,uBAAuB7D,MAAM8D,MAAN9D,CAAa,KAAbA,CAA7B;EAEA,IAAM+D,cAAc1D,aAAa+C,MAAb/C,CAApB;EAEA,IAAMiB,iBAAiBtB,MAAM8D,MAAN9D,CAA6B,EAA7BA,CAAvB;EAEA,IAAMgE,aAAa7D,yBAAnB;EAEA,IAAM8D,WAAWjE,MAAMkE,WAANlE,CACf,UAACqB,iBAAD,EAACA;IACC,IAAMD,gBAAgB2C,YAAYI,OAAlC;IAEA7C,eAAe6C,OAAf7C,CAAuB8C,IAAvB9C,CAA4B;UAQJF;;aAPtBF,SAAS;QACPE,4BADO;QAEPC,oCAFO;QAGPC,gBAAgBA,eAAe6C,OAHxB;QAIP5C,uBAAuB;iBAAMqC,kBAAkB,KAAlBA;SAJtB;QAKPpC,aAAa;iBAAOqC,qBAAqBM,OAArBN,GAA+B;SAL5C;QAMPpC,eAAe;iBAAOoC,qBAAqBM,OAArBN,GAA+B;SAN9C;QAOPnC,oBAAoBN,sIAAeiD,iBAAfjD,MAAgC,IAAhCA,4FAAkCkD,WAAlClD,KAAiD,CAP9D;QAQPO;MARO,CAATT;KADFI;;IAYA,IAAIA,eAAe6C,OAAf7C,CAAuBoB,MAAvBpB,KAAkC,CAAtC,EAAyC;MACvCA,eAAe6C,OAAf7C,CAAuB,CAAvBA;IACF;EACF,CAnBetB,EAoBf,CAAC2B,uBAAD,EAA0BoC,WAA1B,CApBe/D,CAAjB;EAuBA,IAAMuE,eAAevE,MAAMkE,WAANlE,CAAkB;IACrC,IAAMqB,oBACJwB,2EAAoB,UAAC2B,CAAD,EAACA;aAAcA,IAAIT,YAAYI,OAAZJ,CAAqBlC;KAD9D;IAEAoC,SAAS5C,iBAAT4C;EACF,CAJqBjE,EAIlB,CAAC6C,eAAD,EAAkBoB,QAAlB,EAA4BF,WAA5B,CAJkB/D,CAArB;EAMA,IAAMyE,gBAAgBzE,MAAMkE,WAANlE,CAAkB;IACtC,IAAMqB,oBACJyB,8EAAqB,UAAC0B,CAAD,EAACA;aAAcA,IAAIT,YAAYI,OAAZJ,CAAqBlC;KAD/D;IAEAoC,SAAS5C,iBAAT4C;EACF,CAJsBjE,EAInB,CAAC8C,gBAAD,EAAmBmB,QAAnB,EAA6BF,WAA7B,CAJmB/D,CAAtB;EAMA,IAAM0E,4BAA4B1E,MAAMkE,WAANlE,CAAkB;IAClD,IAAI+C,cAAciB,UAAdjB,IAA4BgB,YAAYI,OAAxCpB,IAAmD,CAACc,qBAAqBM,OAA7E,EAAsF;MACpF,IAAM/C,gBAAgB2C,YAAYI,OAAlC;MAEAT,iBAAiBtC,cAAcJ,UAAdI,GAA2B,CAA5CsC;MACAE,kBACEhD,yBAAyBQ,aAAzBR,IAA0CQ,cAAcS,WAAxDjB,GACEQ,cAAckD,WAFlBV;IAIF;EACF,CAVkC5D,EAU/B,CAACgE,UAAD,EAAaD,WAAb,EAA0BhB,UAA1B,CAV+B/C,CAAlC;EAYA,IAAM2E,cAAcvE,iBAAiB,QAAjBA,EAA2BsE,yBAA3BtE,CAApB;EACAJ,MAAM4E,SAAN5E,CACE,SAAS6E,2BAAT,GAASA;IACP,IAAI,CAACd,YAAYI,OAAjB,EAA0B;MACxB,OAAOjE,IAAP;IACF;;IAEAyE,YAAYG,GAAZH,CAAgBZ,YAAYI,OAA5BQ;IACA,OAAOA,YAAYI,MAAnB;EACF,CARF/E,EASE,CAAC2E,WAAD,EAAcZ,WAAd,CATF/D;EAYAA,MAAM4E,SAAN5E,CAAgB0E,yBAAhB1E,EAA2C,CAAC0E,yBAAD,EAA4B9B,QAA5B,CAA3C5C;EAEA;;;;EAGA,IAAMgF,UAAUhF,MAAMkE,WAANlE,CACd,UAACiF,CAAD,EAACA;IACClB,YAAYI,OAAZJ,CAAqBmB,QAArBnB,CAA8B;MAAEoB,MAAMF,EAAEG,MAAFH,GAAWA,EAAEI,MAArB;MAA6BC,UAAU;IAAvC,CAA9BvB;IACAkB,EAAEM,cAAFN;EACF,CAJcjF,EAKd,CAAC+D,WAAD,CALc/D,CAAhB;EAQA,IAAMwF,aAAapF,iBAAiB,OAAjBA,EAA0B4E,OAA1B5E,CAAnB;EACAJ,MAAM4E,SAAN5E,CACE,SAASyF,0BAAT,GAASA;IACP,IAAI,CAAC1B,YAAYI,OAAb,IAAwB,CAACd,gBAA7B,EAA+C;MAC7C,OAAOnD,IAAP;IACF;;IAEAsF,WAAWV,GAAXU,CAAezB,YAAYI,OAA3BqB;IAEA,OAAOA,WAAWT,MAAlB;EACF,CATF/E,EAUE,CAACwF,UAAD,EAAazB,WAAb,EAA0BV,gBAA1B,CAVFrD;EAaA,oBACEA,oBAACO,aAAD,EAACA,wCACKgD,SADLhD,GACKgD;IACJmC,eAAezF,mCAEb,8BAFaA,EAGb8C,eAAe,QAAfA,IAAe,uCAHF9C,CADXsD;IAMJoC,cAAcjB;EANVnB,CADLhD,CAAD,EASGwC,eAAeiB,cAAcA,eAAe4B,SAA5C7C,KAA0DU,aAA1DV,IAA0DU,aACzDzD,oBAACQ,WAAD,EAACA;IACCqF,MAAM3C,SADP1C;IAECsF,SAAS3C,YAFV3C;IAGCuF,WAAU,MAHXvF;IAICwF,WAAW/F,4EAJZO;IAQCyF,SAAS1B;EARV/D,CAAD,CAVJ,EAqBGuC,eAAeiB,cAAcA,eAAe4B,SAA5C7C,KAA0DY,cAA1DZ,IAA0DY,aACzD3D,oBAACQ,WAAD,EAACA;IACCqF,MAAM3C,SADP1C;IAECsF,SAAS3C,YAFV3C;IAGCuF,WAAU,OAHXvF;IAICwF,WAAW/F,6EAJZO;IAQCyF,SAASxB;EARVjE,CAAD,CAtBJ,eAiCER,oBAACkG,KAAD,EAACA;IAAIF,SAAS,4BAAbE;IAA+CC,KAAKpC;EAApDmC,CAAD,eACElG,oBAACkG,KAAD,EAACA;IAAIF,SAAS;EAAbE,CAAD,EAAyDtD,QAAzD,CADF,CAjCF,CADF;AAuCF,CArJO","names":["React","classNames","noop","useAdaptivityHasPointer","useEventListener","useExternRef","easeInOutSine","RootComponent","ScrollArrow","now","performance","Date","roundUpElementScrollLeft","el","Math","ceil","scrollLeft","SCROLL_ONE_FRAME_TIME","doScroll","param","scrollElement","getScrollPosition","animationQueue","onScrollToRightBorder","onScrollEnd","onScrollStart","initialScrollWidth","scrollAnimationDuration","maxLeft","offsetWidth","startLeft","endLeft","startTime","scroll","time","elapsed","min","value","currentLeft","max","requestAnimationFrame","shift","length","HorizontalScroll","children","getScrollToLeft","getScrollToRight","showArrows","_param_showArrows","_param_arrowSize","arrowSize","arrowOffsetY","getRef","scrollOnAnyWheel","_param_scrollOnAnyWheel","restProps","useState","canScrollLeft","setCanScrollLeft","canScrollRight","setCanScrollRight","isCustomScrollingRef","useRef","scrollerRef","hasPointer","scrollTo","useCallback","current","push","firstElementChild","scrollWidth","scrollToLeft","i","scrollToRight","calculateArrowsVisibility","scrollEvent","useEffect","addScrollerRefToScrollEvent","add","remove","onwheel","e","scrollBy","left","deltaX","deltaY","behavior","preventDefault","wheelEvent","addScrollerRefToWheelEvent","baseClassName","onMouseEnter","undefined","size","offsetY","direction","className","onClick","div","ref"],"sources":["C:\\Users\\Я\\Desktop\\myproject\\vk-miniapps\\Koto-app\\node_modules\\@vkontakte\\vkui\\src\\components\\HorizontalScroll\\HorizontalScroll.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { easeInOutSine } from '../../lib/fx';\nimport { HasRef, HTMLAttributesWithRootRef } from '../../types';\nimport { RootComponent } from '../RootComponent/RootComponent';\nimport { ScrollArrow } from '../ScrollArrow/ScrollArrow';\nimport styles from './HorizontalScroll.module.css';\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToRightBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n}\n\nexport type ScrollPositionHandler = (currentPosition: number) => number;\n\nexport interface HorizontalScrollProps\n  extends HTMLAttributesWithRootRef<HTMLDivElement>,\n    HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: ScrollPositionHandler;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: ScrollPositionHandler;\n  arrowSize?: 'm' | 'l';\n  /**\n   * Смещает иконки кнопок навигации по вертикали.\n   */\n  arrowOffsetY?: number | string;\n  showArrows?: boolean | 'always';\n  scrollAnimationDuration?: number;\n  /**\n   * Добавляет возможность прокручивать контент на любое колесо мыши.\n   * По умолчанию прокручивается как любой горизонтальный контент через shift.\n   */\n  scrollOnAnyWheel?: boolean;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nconst roundUpElementScrollLeft = (el: HTMLElement) => Math.ceil(el.scrollLeft);\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToRightBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * максимальное значение сдвига влево\n   */\n  const maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n\n  let startLeft = roundUpElementScrollLeft(scrollElement);\n  let endLeft = getScrollPosition(startLeft);\n\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (roundUpElementScrollLeft(scrollElement) !== Math.max(0, endLeft) && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport const HorizontalScroll = ({\n  children,\n  getScrollToLeft,\n  getScrollToRight,\n  showArrows = true,\n  arrowSize = 'l',\n  arrowOffsetY,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  getRef,\n  scrollOnAnyWheel = false,\n  ...restProps\n}: HorizontalScrollProps) => {\n  const [canScrollLeft, setCanScrollLeft] = React.useState(false);\n  const [canScrollRight, setCanScrollRight] = React.useState(false);\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  const hasPointer = useAdaptivityHasPointer();\n\n  const scrollTo = React.useCallback(\n    (getScrollPosition: ScrollPositionHandler) => {\n      const scrollElement = scrollerRef.current;\n\n      animationQueue.current.push(() =>\n        doScroll({\n          scrollElement,\n          getScrollPosition,\n          animationQueue: animationQueue.current,\n          onScrollToRightBorder: () => setCanScrollRight(false),\n          onScrollEnd: () => (isCustomScrollingRef.current = false),\n          onScrollStart: () => (isCustomScrollingRef.current = true),\n          initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n          scrollAnimationDuration,\n        }),\n      );\n      if (animationQueue.current.length === 1) {\n        animationQueue.current[0]();\n      }\n    },\n    [scrollAnimationDuration, scrollerRef],\n  );\n\n  const scrollToLeft = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToLeft ?? ((i: number) => i - scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n\n  const scrollToRight = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToRight ?? ((i: number) => i + scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n\n  const calculateArrowsVisibility = React.useCallback(() => {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(\n        roundUpElementScrollLeft(scrollElement) + scrollElement.offsetWidth <\n          scrollElement.scrollWidth,\n      );\n    }\n  }, [hasPointer, scrollerRef, showArrows]);\n\n  const scrollEvent = useEventListener('scroll', calculateArrowsVisibility);\n  React.useEffect(\n    function addScrollerRefToScrollEvent() {\n      if (!scrollerRef.current) {\n        return noop;\n      }\n\n      scrollEvent.add(scrollerRef.current);\n      return scrollEvent.remove;\n    },\n    [scrollEvent, scrollerRef],\n  );\n\n  React.useEffect(calculateArrowsVisibility, [calculateArrowsVisibility, children]);\n\n  /**\n   * Прокрутка с помощью любого колеса мыши\n   */\n  const onwheel = React.useCallback(\n    (e: WheelEvent) => {\n      scrollerRef.current!.scrollBy({ left: e.deltaX + e.deltaY, behavior: 'auto' });\n      e.preventDefault();\n    },\n    [scrollerRef],\n  );\n\n  const wheelEvent = useEventListener('wheel', onwheel);\n  React.useEffect(\n    function addScrollerRefToWheelEvent() {\n      if (!scrollerRef.current || !scrollOnAnyWheel) {\n        return noop;\n      }\n\n      wheelEvent.add(scrollerRef.current);\n\n      return wheelEvent.remove;\n    },\n    [wheelEvent, scrollerRef, scrollOnAnyWheel],\n  );\n\n  return (\n    <RootComponent\n      {...restProps}\n      baseClassName={classNames(\n        styles['HorizontalScroll'],\n        'vkuiInternalHorizontalScroll',\n        showArrows === 'always' && styles['HorizontalScroll--withConstArrows'],\n      )}\n      onMouseEnter={calculateArrowsVisibility}\n    >\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && (\n        <ScrollArrow\n          size={arrowSize}\n          offsetY={arrowOffsetY}\n          direction=\"left\"\n          className={classNames(\n            styles['HorizontalScroll__arrow'],\n            styles['HorizontalScroll__arrowLeft'],\n          )}\n          onClick={scrollToLeft}\n        />\n      )}\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && (\n        <ScrollArrow\n          size={arrowSize}\n          offsetY={arrowOffsetY}\n          direction=\"right\"\n          className={classNames(\n            styles['HorizontalScroll__arrow'],\n            styles['HorizontalScroll__arrowRight'],\n          )}\n          onClick={scrollToRight}\n        />\n      )}\n      <div className={styles['HorizontalScroll__in']} ref={scrollerRef}>\n        <div className={styles['HorizontalScroll__in-wrapper']}>{children}</div>\n      </div>\n    </RootComponent>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}