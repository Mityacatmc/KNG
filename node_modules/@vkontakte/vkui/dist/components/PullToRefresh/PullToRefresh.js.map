{"version":3,"sources":["../../../src/components/PullToRefresh/PullToRefresh.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { useGlobalEventListener } from '../../hooks/useGlobalEventListener';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { usePrevious } from '../../hooks/usePrevious';\nimport { useTimeout } from '../../hooks/useTimeout';\nimport { DOMProps, useDOM } from '../../lib/dom';\nimport { Platform } from '../../lib/platform';\nimport { runTapticImpactOccurred } from '../../lib/taptic';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { AnyFunction, HasChildren } from '../../types';\nimport { ScrollContextInterface, useScroll } from '../AppRoot/ScrollContext';\nimport { FixedLayout } from '../FixedLayout/FixedLayout';\nimport { Touch, TouchEvent, TouchProps } from '../Touch/Touch';\nimport TouchRootContext from '../Touch/TouchContext';\nimport { PullToRefreshSpinner } from './PullToRefreshSpinner';\nimport styles from './PullToRefresh.module.css';\n\nfunction cancelEvent(event: any) {\n  if (!event) {\n    return false;\n  }\n  while (event.originalEvent) {\n    event = event.originalEvent;\n  }\n  if (event.preventDefault && event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n  return false;\n}\n\nexport interface PullToRefreshProps extends DOMProps, TouchProps, HasChildren {\n  /**\n   * Будет вызвана для обновления контента (прим.: функция должна быть мемоизированным коллбэком)\n   *\n   * > ⚠️ **Для разработчиков VK Mini Apps**\n   * >\n   * > Сейчас метод под конец выполнения вызывает `runTapticImpactOccurred()`.\n   * >\n   * > В **v6** нужно будет самостоятельно вызывать эту функцию в вашем обработчике `onRefresh()`.\n   * > (см. https://github.com/VKCOM/VKUI/issues/5049). Функцию можете импортировать её из\n   * > бибилиотеки `@vkontakte/vk-bridge-react`.\n   * >\n   * > Чтобы подготовить ваше мини-приложение к обновлению до **v6**, в рамках **v5** вы уже можете\n   * > вызывать `runTapticImpactOccurred()`, но с одним условием: вы должны вернуть результат\n   * > выполнения функции, чтобы исключить двойной вызов. Результат функции — `boolean`. Если\n   * > вернётся `true`, значит, вызывать `runTapticImpactOccurred()` снова со стороны **VKUI** —\n   * > не нужно.\n   * >\n   * > ```jsx\n   * > const onRefresh = React.useCallback(() => {\n   * >  // ...\n   * >  return runTapticImpactOccurred();\n   * > }, []);\n   * >\n   * > // <PullToRefresh onRefresh={onRefresh} />\n   * > ```\n   * >\n   * > Соответственно, в **v6** ничего возвращать уже не потребуется.\n   */\n  onRefresh: AnyFunction;\n  /**\n   * Определяет, выполняется ли обновление. Для скрытия спиннера после получения контента необходимо передать `false`\n   */\n  isFetching?: boolean;\n  /** @ignore */\n  scroll?: ScrollContextInterface;\n}\n\nconst TOUCH_MOVE_EVENT_PARAMS = {\n  cancelable: true,\n  passive: false,\n};\n\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\nexport const PullToRefresh = ({\n  children,\n  isFetching,\n  onRefresh,\n  className,\n  ...restProps\n}: PullToRefreshProps) => {\n  const platform = usePlatform();\n  const scroll = useScroll();\n  const { document } = useDOM();\n  const prevIsFetching = usePrevious(isFetching);\n\n  const initParams = React.useMemo(\n    () => ({\n      start: platform === Platform.IOS ? -10 : -45,\n      max: platform === Platform.IOS ? 50 : 80,\n      maxY: platform === Platform.IOS ? 400 : 80,\n      refreshing: platform === Platform.IOS ? 36 : 50,\n      positionMultiplier: platform === Platform.IOS ? 0.21 : 1,\n    }),\n    [platform],\n  );\n\n  const [spinnerY, setSpinnerY] = React.useState(initParams.start);\n  const [watching, setWatching] = React.useState(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n  const [canRefresh, setCanRefresh] = React.useState(false);\n  const [touchDown, setTouchDown] = React.useState(false);\n  const prevTouchDown = usePrevious(touchDown);\n\n  const touchY = React.useRef(0);\n  const [contentShift, setContentShift] = React.useState(0);\n  const [spinnerProgress, setSpinnerProgress] = React.useState(0);\n\n  const onWindowTouchMove = (event: Event) => {\n    if (refreshing) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  useGlobalEventListener(document, 'touchmove', onWindowTouchMove, TOUCH_MOVE_EVENT_PARAMS);\n\n  const resetRefreshingState = React.useCallback(() => {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n\n  const onRefreshingFinish = React.useCallback(() => {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n\n  const { set: setWaitFetchingTimeout, clear: clearWaitFetchingTimeout } = useTimeout(\n    onRefreshingFinish,\n    1000,\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [prevIsFetching, isFetching, onRefreshingFinish]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearWaitFetchingTimeout();\n    }\n  }, [isFetching, prevIsFetching, clearWaitFetchingTimeout]);\n\n  const runRefreshing = React.useCallback(() => {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      setWaitFetchingTimeout();\n\n      setRefreshing(true);\n      setSpinnerY((prevSpinnerY) =>\n        platform === Platform.IOS ? prevSpinnerY : initParams.refreshing,\n      );\n\n      const runTapticImpactOccurredCalled = onRefresh();\n      // TODO [>=6]: удалить блок кода (#5049)\n      if (!runTapticImpactOccurredCalled) {\n        runTapticImpactOccurred('light');\n      }\n    }\n  }, [refreshing, onRefresh, setWaitFetchingTimeout, platform, initParams.refreshing]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [\n    initParams,\n    prevIsFetching,\n    isFetching,\n    onRefreshingFinish,\n    prevTouchDown,\n    touchDown,\n    refreshing,\n    canRefresh,\n    runRefreshing,\n  ]);\n\n  const onTouchStart = (e: TouchEvent) => {\n    if (refreshing) {\n      cancelEvent(e);\n    }\n    setTouchDown(true);\n  };\n\n  const onTouchMove = (e: TouchEvent) => {\n    const { isY, shiftY } = e;\n    const { start, max } = initParams;\n    const pageYOffset = scroll?.getScroll().y;\n\n    if (watching && touchDown) {\n      cancelEvent(e);\n\n      const { positionMultiplier, maxY } = initParams;\n\n      const shift = Math.max(0, shiftY - touchY.current);\n\n      const currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      const progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n\n      if (progress > 85 && !refreshing && platform === Platform.IOS) {\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(e);\n\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n\n  const onTouchEnd = () => {\n    setWatching(false);\n    setTouchDown(false);\n  };\n\n  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;\n  let contentTransform = '';\n\n  if (platform === Platform.IOS && refreshing && !touchDown) {\n    contentTransform = 'translate3d(0, 100px, 0)';\n  } else if (platform === Platform.IOS && (contentShift || refreshing)) {\n    contentTransform = `translate3d(0, ${contentShift}px, 0)`;\n  }\n\n  return (\n    <TouchRootContext.Provider value={true}>\n      <Touch\n        {...restProps}\n        onStart={onTouchStart}\n        onMove={onTouchMove}\n        onEnd={onTouchEnd}\n        className={classNames(\n          styles['PullToRefresh'],\n          platform === Platform.IOS && styles['PullToRefresh--ios'],\n          watching && styles['PullToRefresh--watching'],\n          refreshing && styles['PullToRefresh--refreshing'],\n          className,\n        )}\n      >\n        <FixedLayout className={styles['PullToRefresh__controls']} useParentWidth>\n          <PullToRefreshSpinner\n            style={{\n              transform: spinnerTransform,\n              WebkitTransform: spinnerTransform,\n              opacity: watching || refreshing || canRefresh ? 1 : 0,\n            }}\n            on={refreshing}\n            progress={refreshing ? undefined : spinnerProgress}\n          />\n        </FixedLayout>\n\n        <div\n          className={styles['PullToRefresh__content']}\n          style={{\n            transform: contentTransform,\n            WebkitTransform: contentTransform,\n          }}\n        >\n          {children}\n        </div>\n      </Touch>\n    </TouchRootContext.Provider>\n  );\n};\n"],"names":["React","classNames","clamp","useGlobalEventListener","usePlatform","usePrevious","useTimeout","useDOM","Platform","runTapticImpactOccurred","useIsomorphicLayoutEffect","useScroll","FixedLayout","Touch","TouchRootContext","PullToRefreshSpinner","cancelEvent","event","originalEvent","preventDefault","cancelable","stopPropagation","TOUCH_MOVE_EVENT_PARAMS","passive","PullToRefresh","children","isFetching","onRefresh","className","restProps","platform","scroll","document","prevIsFetching","initParams","useMemo","start","IOS","max","maxY","refreshing","positionMultiplier","useState","spinnerY","setSpinnerY","watching","setWatching","setRefreshing","canRefresh","setCanRefresh","touchDown","setTouchDown","prevTouchDown","touchY","useRef","contentShift","setContentShift","spinnerProgress","setSpinnerProgress","onWindowTouchMove","resetRefreshingState","useCallback","onRefreshingFinish","set","setWaitFetchingTimeout","clear","clearWaitFetchingTimeout","undefined","runRefreshing","prevSpinnerY","runTapticImpactOccurredCalled","onTouchStart","e","onTouchMove","isY","shiftY","pageYOffset","getScroll","y","shift","Math","current","currentY","progress","abs","onTouchEnd","spinnerTransform","contentTransform","Provider","value","onStart","onMove","onEnd","useParentWidth","style","transform","WebkitTransform","opacity","on","div"],"mappings":"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"}